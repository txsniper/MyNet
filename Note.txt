                muduo的一些设计解析
1.  线程的设计(Thread.h，Thread.cc)：
    线程其实分为两个部分，一是其他线程可见的，另一部分是其他线程不可见的，
其他线程可以通过可见的部分启动线程(start)，等待(join)，获取线程的Thread Id，
因此muduo在设计Thread类的时候分了两个部分，Thread class是其他线程可见的，
ThreadData则是执行线程私有的部分，两者都保存了执行线程的Thread Id，因此采用
Thread class 采用shared_ptr来保存Thread id，而ThreadData用weak_ptr来保存


2.  读写文件(FileUtil.h)
    2.1 读文件ReadSmallFile(直接使用linux API)，写文件AppendFile(使用C库函数)，
而不使用API，因为AppendFile需要手动的控制flush，如果使用write系统调用，可
能会因为频繁的write降低性能(write需要进行用户空间和内核空间的转换)。
    2.2 AppendFile写文件的时候使用fwrite_unlocked，因为muduo的AppendFile用来
写日志文件，每个文件的写入只有一个线程去完成，因此不需要fwrite来加锁互斥访问

3.  Singleton(Singleton.h)
    Singleton设计为模板类，数据成员为static，使得每个类型只有一个对象，在销毁
对象时，使用sizeof(T)检测T是否是一个完整类型，因为对不完整类型的指针调用delete
时只会销毁指针，不会调用它的析构函数。
    不完整类型(reference):
    http://kelvinh.github.io/blog/2013/08/28/memory-leak-of-incomplete-type/
    http://stackoverflow.com/questions/5606750/deletion-of-pointer-to-incomplete-type-and-smart-pointers

5.  ThreadLocalSingleton(ThreadLocalSingleton.h)
    用来保存每一个线程的单例对象，方便在任何时候操作当前线程的对象(利用instance()获得当前
    线程的对象)
    eg: /examples/asio/chat/server_threaded_highperformance.cc ，其中使用ThreadLocalSingleton来
    保存每一个线程的网络连接池

6.  ProcessInfo获取进程信息(ProcessInfo.h, ProcessInfo.cc)
    通过读"/proc/self/"下的文件获取当前进程的信息(打开的文件数量:/proc/self/fd/，线程数量:
    /proc/self/task/ 等等)

7.  日期计算(Date.h Date.cc)
    日期计算使用儒略日(Julian Day)方式，算法见：
    http://www.faqs.org/faqs/calendars/faq/part2/

8.  计时(Timestamp.h Timestamp.cc)
    Timestamp使用了UTC时间，精度为微秒(使用gettimeofday实现，在新的内核上，gettimeofday不再是
    syscall，从而没有内核态和用户态切换的开销)。
    对于精度要求不高的场合，直接使用time()获取时间。
        eg: 多线程日志的实现中计时功能

9.  多线程日志的实现:
    9.1 使用样例：
    主线程:
        void outputFunc(const char* line, size_t n)
        {
            .....;
            AsyncLogging.append(line, n);
            //还可以输出到 stdout or /dev/null，这里以输出到AsyncLogging为例
        }
        muduo::Logger::setOutput(outputFunc);

    user线程:
        LOG_INFO << "Some info need to record";   ===> 创建一个Logger类型的匿名对象，向它的LogStream写入
                         ||                            数据，匿名对象随后销毁，调用Logger的析构函数,
                         ||                            ~Logger()会根据设定的输出函数outputFunc将LogStream
                         ||                             中的数据输出
                        \  /
                         \/
        AsyncLogging::append(const char* line, size_t n); ===> append函数通过加锁保证不同的user线程在append时
                                                               的线程安全，将数据写入到buffer中, user线程日志
                                                               写入操作完成

    AsyncLogging::threadFunc 日志线程:
        根据策略将日志写入文件，详细见《linux多线程服务端编程》第五章 P107

        LOG_INFO(or LOG_DEBUG 等宏):
        LogFile:   日志文件类，每一个LogFile代表了以basename_为基准文件名的一类日志文件，在
                   一定条件下(超时 and 写入数据的大小)flush或roll，外界只需要提供运行参数(basename, flushInterval)
                   并写入数据即可
        LogStream: 包含一个缓冲区的日志流，通过重载operator<<实现将各种类型的数据格式化写入
                   缓冲区。
        Logger(Logging.h): Logger类提供了对LogStream的操作，并根据Logger定义了LOG_INFO等用户
                   使用的输入宏
        AsyncLogging: 封装了高效的日志处理核心流程

    9.2 要点：(1). 每个线程写一个日志文件，因此可以使用fwrite_nonlocked
              (2). 日志文件的滚动(roll)有两个条件：1. rollSize  2. rollPeriod，
                   日志文件写到磁盘(flush)也是两个条件：1. 向日志文件写入数据(append)次数
                   2. flush Period.
              (3). 定时flush或roll并没有使用一个timer去跑(再次注意linux下的timer和windows很不同，
                   不能用windows的想法来实现)，muduo使用Condition(条件变量)的超时等待功能实现
                   定时flush和定时roll
                   eg: AsyncLogging.cc : AsyncLogging::threadFunc
                                        ----> cond_.waitForSeconds(flushInterval_);

