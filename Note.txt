                muduo的一些设计解析
1.  线程的设计(Thread.h，Thread.cc)：
    线程其实分为两个部分，一是其他线程可见的，另一部分是其他线程不可见的，
其他线程可以通过可见的部分启动线程(start)，等待(join)，获取线程的Thread Id，
因此muduo在设计Thread类的时候分了两个部分，Thread class是其他线程可见的，
ThreadData则是执行线程私有的部分，两者都保存了执行线程的Thread Id，因此采用
Thread class 采用shared_ptr来保存Thread id，而ThreadData用weak_ptr来保存


2.  读写文件(FileUtil.h)
    2.1 读文件ReadSmallFile(直接使用linux API)，写文件AppendFile(使用C库函数)，
而不使用API，因为AppendFile需要手动的控制flush，如果使用write系统调用，可
能会因为频繁的write降低性能(write需要进行用户空间和内核空间的转换)。
    2.2 AppendFile写文件的时候使用fwrite_unlocked，因为muduo的AppendFile用来
写日志文件，每个文件的写入只有一个线程去完成，因此不需要fwrite来加锁互斥访问

3.  Singleton(Singleton.h)
    Singleton设计为模板类，数据成员为static，使得每个类型只有一个对象，在销毁
对象时，使用sizeof(T)检测T是否是一个完整类型，因为对不完整类型的指针调用delete
时只会销毁指针，不会调用它的析构函数。
    不完整类型(reference):
    http://kelvinh.github.io/blog/2013/08/28/memory-leak-of-incomplete-type/
    http://stackoverflow.com/questions/5606750/deletion-of-pointer-to-incomplete-type-and-smart-pointers

5.  ThreadLocalSingleton(ThreadLocalSingleton.h)
    用来保存每一个线程的单例对象，方便在任何时候操作当前线程的对象(利用instance()获得当前
    线程的对象)
    eg: /examples/asio/chat/server_threaded_highperformance.cc ，其中使用ThreadLocalSingleton来
    保存每一个线程的网络连接池

6.  ProcessInfo获取进程信息(ProcessInfo.h, ProcessInfo.cc)
    通过读"/proc/self/"下的文件获取当前进程的信息(打开的文件数量:/proc/self/fd/，线程数量:
    /proc/self/task/ 等等)
