                muduo的一些设计解析
1.  线程的设计(Thread.h，Thread.cc)：
    线程其实分为两个部分，一是其他线程可见的，另一部分是其他线程不可见的，
其他线程可以通过可见的部分启动线程(start)，等待(join)，获取线程的Thread Id，
因此muduo在设计Thread类的时候分了两个部分，Thread class是其他线程可见的，
ThreadData则是执行线程私有的部分，两者都保存了执行线程的Thread Id，因此采用
Thread class 采用shared_ptr来保存Thread id，而ThreadData用weak_ptr来保存


2.  读写文件(FileUtil.h)
    2.1 读文件ReadSmallFile(直接使用linux API)，写文件AppendFile(使用C库函数)，
而不使用API，因为AppendFile需要手动的控制flush，如果使用write系统调用，可
能会因为频繁的write降低性能(write需要进行用户空间和内核空间的转换)。
    2.2 AppendFile写文件的时候使用fwrite_unlocked，因为muduo的AppendFile用来
写日志文件，每个文件的写入只有一个线程去完成，因此不需要fwrite来加锁互斥访问

3.  Singleton(Singleton.h)
    Singleton设计为模板类，数据成员为static，使得每个类型只有一个对象，在销毁
对象时，使用sizeof(T)检测T是否是一个完整类型，因为对不完整类型的指针调用delete
时只会销毁指针，不会调用它的析构函数。
    不完整类型(reference):
    http://kelvinh.github.io/blog/2013/08/28/memory-leak-of-incomplete-type/
    http://stackoverflow.com/questions/5606750/deletion-of-pointer-to-incomplete-type-and-smart-pointers

5.  ThreadLocalSingleton(ThreadLocalSingleton.h)
    用来保存每一个线程的单例对象，方便在任何时候操作当前线程的对象(利用instance()获得当前
    线程的对象)
    eg: /examples/asio/chat/server_threaded_highperformance.cc ，其中使用ThreadLocalSingleton来
    保存每一个线程的网络连接池

6.  ProcessInfo获取进程信息(ProcessInfo.h, ProcessInfo.cc)
    通过读"/proc/self/"下的文件获取当前进程的信息(打开的文件数量:/proc/self/fd/，线程数量:
    /proc/self/task/ 等等)

7.  日期计算(Date.h Date.cc)
    日期计算使用儒略日(Julian Day)方式，算法见：
    http://www.faqs.org/faqs/calendars/faq/part2/

8.  计时(Timestamp.h Timestamp.cc)
    Timestamp使用了UTC时间，精度为微秒(使用gettimeofday实现，在新的内核上，gettimeofday不再是
    syscall，从而没有内核态和用户态切换的开销)。
    对于精度要求不高的场合，直接使用time()获取时间。
        eg: 多线程日志的实现中计时功能

9.  多线程日志的实现:
    9.1 基础类
        LOG_INFO(or LOG_DEBUG 等宏):
        LogFile:   日志文件类，每一个LogFile代表了以basename_为基准文件名的一类日志文件，在
                   一定条件下(超时 and 写入数据的大小)flush或roll，外界只需要提供运行参数(basename, flushInterval)
                   并写入数据即可
        LogStream: 包含一个缓冲区的日志流，通过重载operator<<实现将各种类型的数据格式化写入
                   缓冲区。
        Logger(Logging.h): Logger类提供了对LogStream的操作，并根据Logger定义了LOG_INFO等用户
                   使用的输入宏，提供了重定向输出的接口(setOutput)，当Logger在析构的时候会调用
                   重定向的函数OutputFunc将LogStream中的数据输出到指定位置

        AsyncLogging: 封装了高效的日志处理核心流程

    9.2 使用样例：
    主线程:
        void outputFunc(const char* line, size_t n)
        {
            .....;
            AsyncLogging.append(line, n);
            //还可以输出到 stdout or /dev/null，这里以输出到AsyncLogging为例
        }
        muduo::Logger::setOutput(outputFunc);

    user线程:
        LOG_INFO << "Some info need to record";   ===> 创建一个Logger类型的匿名对象，向它的LogStream写入
                         ||                            数据，匿名对象随后销毁，调用Logger的析构函数,
                         ||                            ~Logger()会根据设定的输出函数outputFunc将LogStream
                         ||                             中的数据输出
                        \  /
                         \/
        AsyncLogging::append(const char* line, size_t n); ===> append函数通过加锁保证不同的user线程在append时
                                                               的线程安全，将数据写入到buffer中, user线程日志
                                                               写入操作完成

    AsyncLogging::threadFunc 日志线程:
        根据策略将日志写入文件，详细见《linux多线程服务端编程》第五章 P107


    9.3 要点：(1). 每个线程写一个日志文件，因此可以使用fwrite_nonlocked
              (2). 日志文件的滚动(roll)有两个条件：1. rollSize  2. rollPeriod，
                   日志文件写到磁盘(flush)也是两个条件：1. 向日志文件写入数据(append)次数
                   2. flush Period.
              (3). 定时flush或roll并没有使用一个timer去跑(再次注意linux下的timer和windows很不同，
                   不能用windows的想法来实现)，muduo使用Condition(条件变量)的超时等待功能实现
                   定时flush和定时roll
                   eg: AsyncLogging.cc : AsyncLogging::threadFunc
                                        ----> cond_.waitForSeconds(flushInterval_);

    9.4 一些特点：
              (1). 日志级别的设定可以通过环境变量来进行。(Logging.cc --- initLogService)
              (2). 通过字符数组的方式将字符串长度的计算从运行期提到编译期，见class T

10. boost的一些用法：
    10.1 boost::bind : boost::bind不仅能用来绑定函数传递参数，还用在foreach循环中调用每个成员
         的函数
         boost::ptr_vector<muduo::Thread> threads_;
         ... // 向threads_中填充Thread
         foreach(threads_.begin(), threads_.end(), boost::bind(&muduo::Thread::start, _1));
         等价于：
                for(boost::ptr_vector<muduo::Thread>::const_iterator it = threads_.begin(); it != threads_.end(); ++it)
                {
                    (*it)->start();
                }

        类似的方式：
            #include <algorithm>  // for_each
            #include <functional> // bind

            // ...

            std::for_each(container.begin(), container.end(), std::bind(&Type::func));

            std::for_each(foo_vector.begin(), foo_vector.end(),std::bind(&Foo::func, std::placeholders::_1));

            reference:
                http://stackoverflow.com/questions/719043/call-member-function-on-each-element-in-a-container

    10.2 boost 测试套件，需要注意的是利用动态链接的形式使用boost单元测试：
         在测试的CPP文件中添加:
         #define BOOST_TEST_MAIN
         #define BOOST_TEST_DYN_LINK
         #include <boost/test/unit_test.hpp>

         在CMakelist中添加编译依赖:这里以logstream_test为例：
          if(BOOSTTEST_LIBRARY)
                add_executable(logstream_test LogStream_test.cc)
                target_link_libraries(logstream_test mynet_base boost_unit_test_framework)
                add_test(NAME logstream_test COMMAND logstream_test)
          endif()
